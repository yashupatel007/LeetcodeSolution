
// class Solution {
// public:
// void permutation( vector<int>&nums,vector<vector<int>>&ans,vector<int>&temp,vector<bool>&visited){
//         if(temp.size()==visited.size()){ // base condition
//             ans.push_back(temp);
//             return;
//         }
//         for(int i=0;i<visited.size();i++){ //check not occured in visited vector
//             if(visited[i]==0){ // not occured
//                 visited[i]=1; //make occured
//                 temp.push_back(nums[i]);//temp me daldo
//                 permutation(nums,ans,temp,visited);//call for next element
//                 visited[i]=0;//make not occured after call,to take it again
//                 temp.pop_back();//[1,2, ]->[1, , ] thats why 

//             }
//         }
    
// }
//     vector<vector<int>> permute(vector<int>& nums) {
//         vector<vector<int>>ans;
//         vector<int>temp;
//         vector<bool>visited(nums.size(),0);
//         permutation(nums,ans,temp,visited);
//         return ans;
//     }
// };
//2nd (swap approach)->more efficient
class Solution {
public:
        void permutation(vector<int>&nums,vector<vector<int>>&ans,int index){
            if(index==nums.size()){//base case
                ans.push_back(nums);
                return;
            }
            for(int i=index;i<nums.size();i++){//nums ke 1st elem ko rest se swap karo
                swap(nums[i],nums[index]);//1st ko next se swap done
                permutation(nums,ans,index+1);//age badho
                swap(nums[i],nums[index]);//next case me jane se pehle unswap karo
                //[1,2,3]->swap->[2,1,3]->unswap for next case->[1,2,3]->swap->[3,2,1]
            }
        }
        vector<vector<int>> permute(vector<int>& nums) {
            vector<vector<int>>ans;
            int index=0;
            permutation(nums,ans,index);
            return ans;
}
};
